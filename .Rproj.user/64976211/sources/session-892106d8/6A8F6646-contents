# ==============================================================================
# ==============================================================================
# Set of procedures for Consumption-habit model
# ==============================================================================
# ==============================================================================


simul.model <- function(Model,nb.sim){
  
  S.bar <- Model$sigma.eps * sqrt(Model$Gamma / (1 - Model$phi - Model$b/Model$Gamma))
  s.bar <- log(S.bar)
  s.max <- s.bar + .5*(1-S.bar^2)
  
  #avg.rf <- - log(delta) + Gamma * g - (Gamma*(1 - phi) - b)/2
  
  nu <- rnorm(nb.sim)*Model$sigma.eps
  bernoulli <- 1*(runif(nb.sim)<Model$p)
  
  simul.s <- NULL
  simul.delta.c <- NULL
  s <- s.bar
  delta.c <- Model$g
  
  for(t in 1:nb.sim){
    lambda.s <- 1/S.bar * sqrt(1 - 2*(s - s.bar)) - 1
    
    delta.c <- g + nu[t] - Model$eta * bernoulli[t]
    
    s <- min((1 - Model$phi)*s.bar + Model$phi*s +
               lambda.s * (nu[t] - Model$eta * bernoulli[t] + Model$p * Model$eta),s.max)
    simul.s       <- c(simul.s,s)
    simul.delta.c <- c(simul.delta.c,delta.c)
  }
  return(list(simul.s = simul.s,
              lambda.s = lambda.s,
              bernoulli = bernoulli,
              simul.delta.c = simul.delta.c
  ))
}

simul.z <- function(P,ini.state,T,nb.of.periods.with.ini.state=1){
  # This function simulates a Markow chain whose
  # transition probabilities are in P, specifically,
  # the (i,j) entry of P is the proba to switch from state i to state j.
  # "ini.state" indicates in which state the chain begins (on date t=1). 
  #      ini.state is an integer that is lower than the dimension of P
  # if nb.of.periods.with.ini.state>1 then ini.state replicated nb.of.periods.with.ini.state times
  
  N <- dim(P)[1]
  
  z.integer <- ini.state
  all.z.integer <- rep(z.integer,nb.of.periods.with.ini.state)
  all.z <- matrix(0,N,nb.of.periods.with.ini.state)
  all.z[z.integer,] <- 1
  
  u <- runif(T-1)
  for(i in 1:(T-nb.of.periods.with.ini.state)){
    vector.of.cum.proba <- cumsum(P[z.integer,])
    aux <- u[i] - vector.of.cum.proba
    negative.aux <- which(aux<0)
    z.integer <- negative.aux[1]
    all.z.integer <- c(all.z.integer,z.integer)
    aux.z <- matrix(0,N,1)
    aux.z[z.integer] <- 1
    all.z <- cbind(all.z,aux.z)
  }
  
  return(list(
    all.z.integer = all.z.integer,
    all.z = all.z
  ))
}

simul.model.solved <- function(res.prices,T,nb.of.periods.with.ini.state=1){
  # This function takes the output of "compute.prices" as an input
  # T is the number of periods on which it is simulated
  # The initial state is the stationary state.
  # if nb.of.periods.with.ini.state>1, then the initial state is replicated nb.of.periods.with.ini.state times.
  # Simulated yields are not annualized but consistent with the model periodicity.
  
  N <- dim(res.prices$P)[1]
  
  res.mom.pi.z <- compute.uncond.mom.pi.z(res.prices$Model.solved)
  
  ini.state <- round(sum((1:N)*res.mom.pi.z$E.z)) # average value of z.integer
  sim.z <- simul.z(res.prices$Model.solved$P,ini.state,T,nb.of.periods.with.ini.state)
  
  # Compute associated series of nu_t shocks:
  mu <- res.prices$values.s
  lambda <- res.prices$Model.solved$lambda.s
  phi <- res.prices$Model.solved$phi
  s.bar <- res.prices$Model.solved$s.bar
  B <- matrix(1/lambda,ncol=1) %*% matrix(mu,nrow=1) -
    (1 - phi) * s.bar * matrix(1/lambda,N,N) -
    phi * matrix(mu/lambda,ncol=1) %*% matrix(1,1,N)
  
  indices.nu.in.B <- sim.z$all.z.integer[1:(T-1)] + N*(sim.z$all.z.integer[2:T] - 1)
  nu <- c(0,B[indices.nu.in.B]) # 0 is added for nu to be of dimension T.
  
  sim.y  <- res.prices$Model.solved$g + 
    res.prices$Model.solved$rho.y * nu +
    res.prices$Model.solved$sigma.y * rnorm(T)
  sim.d  <- res.prices$Model.solved$d.bar + 
    res.prices$Model.solved$rho.d * nu +
    res.prices$Model.solved$sigma.d * rnorm(T)
  
  sim.y[1:nb.of.periods.with.ini.state] <- res.prices$Model.solved$g
  sim.d[1:nb.of.periods.with.ini.state] <- res.prices$Model.solved$d.bar
  
  pi.t <- res.prices$Model.solved$pi.bar
  sim.pi <- rep(pi.t,nb.of.periods.with.ini.state)
  
  # inflation simulation:
  for(i in (nb.of.periods.with.ini.state+1):T){
    pi.t <- (1 - res.prices$Model.solved$psi) * res.prices$Model.solved$pi.bar +
      res.prices$Model.solved$psi * pi.t +
      res.prices$Model.solved$rho.pi * nu[i] +
      res.prices$Model.solved$sigma.pi * rnorm(1)
    sim.pi <- c(sim.pi,pi.t)
  }
  
  vec.maturities <- 1:length(c(res.prices$all.nom.bond.b))
  
  # ===============================================
  # Nominal yields:
  res.prices$all.nom.bond.F[res.prices$all.nom.bond.F<=0] <- 10^(-50)
  nom.yields <- 1/vec.maturities * (
    matrix(res.prices$all.nom.bond.b,ncol=1) %*% matrix(sim.pi,nrow=1) - 
      log(res.prices$all.nom.bond.F %*% sim.z$all.z)
  )
  
  # ===============================================
  # Real yields:
  rea.yields <- 1/vec.maturities * (
    - log(res.prices$all.rea.bond.prices %*% sim.z$all.z)
  )
  
  # ===============================================
  # GDP-indexed bond yields:
  GDP.yields <- 1/vec.maturities * (
    - log(res.prices$all.GDP.bond.prices %*% sim.z$all.z)
  )
  
  return(list(
    sim.z = sim.z$all.z,
    sim.z.integer = sim.z$all.z.integer,
    sim.nu = nu,
    sim.y = sim.y,
    sim.d = sim.d,
    sim.pi = sim.pi,
    nom.yields = nom.yields,
    rea.yields = rea.yields,
    GDP.yields = GDP.yields
  ))
}


cdf.c.innov <- function(q,arguments){
  if(length(arguments)==1){
    # In this case, growth ~ N(0,arguments[1]^2)
    proba <- pnorm(q/arguments[1])
  }else{
    # In this case, Delta c_t ~ (1-B)*N(mu * p/(1-p),arguments[1]^2) + B*N(-mu,arguments[1]^2)
    #  with mu=argument[2] and p=argument[3] in [0,1] 
    # and B i.i.d. Bernoulli of parameter p
    sigma <- arguments[1]
    mu <- arguments[2]
    p <- arguments[3]
    proba <- (1-p)*pnorm((q-mu*p/(1-p))/arguments[1]) + p*pnorm((q+mu)/arguments[1])
  }
  return(proba)
}


# arguments <- c(1,0,.1)
# q <- seq(-4,4,by=.01)
# plot(q,cdf.c.innov(q,arguments),type="l")


f.4.make.S.values <- function(x,curvature){
  return(exp(-curvature * x * (x-1)))
}

make.S.values <- function(S.max,curvature=1,nb.values.s){
  min.dev <- 1/nb.values.s
  step <- (1-min.dev)/nb.values.s
  aux.values <- seq(.5*min.dev,1-.5*min.dev,by=step)
  aux.steps <- f.4.make.S.values(aux.values,curvature)
  sum.steps <- sum(aux.steps)
  steps <- S.max * (aux.steps/sum.steps)
  values.S <- cumsum(steps)[1:nb.values.s]
  return(values.S)
}
#plot(make.S.values(.1,curvature = 20,nb.values.s = 100))


compute.prices <- function(Model,
                           vec.maturities, # maturities considered (expressed in number of model periods)
                           nb.values.s = NB.values.s,
                           h.stock=1,
                           curvature=1, # this controls the dispersion of S values in the grid (the higher this parameter, the larger the number of values XXX)
                           grid.4.S = NaN # If it is non NaN, then these values are used as a grid for S
){
  # This function computes various prices and yields.
  # Importantly, it also derives Pi, the matrix of transition probabilities.
  # Yields output are annualized.
  
  Var.nu <- Model$sigma.eps^2 +
    (1 - Model$p) * (Model$eta * Model$p / (1 - Model$p))^2 +
    Model$p * Model$eta^2
  #S.bar <- Model$sigma.eps * sqrt(Model$Gamma / (1 - Model$phi - Model$b/Model$Gamma))
  S.bar <- sqrt(Var.nu) * sqrt(Model$Gamma / (1 - Model$phi - Model$b/Model$Gamma))
  s.bar <- log(S.bar)
  s.max <- s.bar + .5*(1-S.bar^2)
  S.max <- exp(s.max)
  
  Model.solved <- Model
  Model.solved$s.max <- s.max
  Model.solved$S.max <- S.max
  Model.solved$s.bar <- s.bar
  Model.solved$S.bar <- S.bar
  
  if(is.na(grid.4.S[1])){
    min.dev <- S.max/nb.values.s
    step <- (S.max-min.dev)/(nb.values.s-1)
    #values.S <- seq(.5*min.dev,S.max-.5*min.dev,by=step)
    values.S <- make.S.values(S.max,curvature,nb.values.s)
  }else{
    values.S <- grid.4.S
    nb.values.s <- length(values.S)
  }
  
  values.s <- log(values.S)
  Model.solved$values.s <- values.s
  Model.solved$nb.values.s <- length(Model.solved$values.s)
  
  # Look for s.bar:
  deviation <- (s.bar - values.s)^2
  index.s.bar <- which(deviation==min(deviation))
  
  lambda.s <- pmax(1/S.bar * sqrt(1 - 2*(values.s - s.bar)) - 1,0)
  
  Model.solved$lambda.s <- lambda.s
  
  # ======================================================================================
  # Computation of the matrix of transition probabilities
  
  values.s.ext <- c(-40,values.s,40)
  X1 <- (matrix(1/lambda.s,ncol=1) %*% matrix(1,1,nb.values.s))*
    (
      .5 * matrix(1,nb.values.s,1) %*% matrix(values.s.ext[3:(nb.values.s+2)]+
                                                values.s.ext[2:(nb.values.s+1)],nrow=1) -
        (1 - Model$phi) * s.bar - Model$phi * matrix(values.s,ncol=1) %*% matrix(1,1,nb.values.s)
    )
  X2 <- (matrix(1/lambda.s,ncol=1) %*% matrix(1,1,nb.values.s))*
    (
      .5 * matrix(1,nb.values.s,1) %*% matrix(values.s.ext[2:(nb.values.s+1)]+
                                                values.s.ext[1:(nb.values.s)],nrow=1) -
        (1 - Model$phi) * s.bar - Model$phi * matrix(values.s,ncol=1) %*% matrix(1,1,nb.values.s)
    )
  
  arguments <- c(Model$sigma.eps,
                 Model$eta,
                 Model$p)
  P <- cdf.c.innov(X1,arguments) - cdf.c.innov(X2,arguments)
  
  Q.num <- exp(-Model$Gamma * (1 + 1/matrix(lambda.s,ncol=1)) %*% matrix(values.s,nrow=1))
  Q.num[Q.num==Inf] <- 10^300
  Q.denom <- (Q.num * P) %*% matrix(1,nb.values.s,nb.values.s)
  Q <- (Q.num/Q.denom) * P
  
  matrix.M.on.E.M <- Q.num/Q.denom
  
  Model.solved$P <- P
  Model.solved$Q <- Q
  
  
  # ======================================================================================
  # Computation of short-term real rates
  
  M.AUX <- - Model$Gamma * matrix(1 + 1/lambda.s,nb.values.s,1) %*% matrix(values.s,1,nb.values.s)
  M.AUX[M.AUX>700] <- 700
  
  mu.r <- - log(Model$delta) + Model$Gamma * Model$g - Model$Gamma * values.s -
    Model$Gamma * (1 - Model$phi) * s.bar / lambda.s - Model$Gamma * Model$phi * values.s / lambda.s -
    log(
      apply(
        P * exp(M.AUX),
        1,sum
      )
    )
  # Closed-form formula when Gaussian shocks (p=0 or eta=0):
  mu.r.1 <- - log(Model$delta) + Model$Gamma * Model$g - .5*(Model$Gamma * (1 - Model$phi) - Model$b) +
    Model$b * (s.bar - values.s)
  
  Model.solved$mu.r <- mu.r
  
  # Compute Maximum Sharpe ratio
  A <- matrix(exp(-mu.r),nb.values.s,nb.values.s) * matrix.M.on.E.M
  cond.var.SDF <- diag(P %*% (A * A) - (P %*% A) * (P %*% A))
  cond.max.Sharpe.ratios <- sqrt(cond.var.SDF) / exp(-mu.r)
  
  
  # ======================================================================================
  # Computation of bond prices and rates
  
  all.rea.bond.prices <- NULL
  all.rea.bond.yields <- NULL
  all.nom.bond.F <- NULL
  all.nom.bond.b <- NULL
  all.GDP.bond.prices <- NULL
  all.GDP.bond.yields <- NULL
  
  # For real bonds (initialization):
  matrix.real.h_1 <- diag(nb.values.s)
  
  # For GDP-indexed bonds (initialization):
  E.exp.rhoy.nu <- exp(Model$sigma.eps^2 * Model$rho.y^2/2) * (
    (1-Model$p)*exp(Model$rho.y * Model$eta * Model$p/(1-Model$p)) +
      Model$p * exp(- Model$rho.y * Model$eta)
  ) # computation of E(exp(rho_y * nu))
  
  H <- 1/(E.exp.rhoy.nu) * exp(
    matrix(- mu.r - (1 - Model$phi) * Model$rho.y * s.bar / lambda.s - Model$phi * Model$rho.y * values.s / lambda.s,
           nb.values.s,nb.values.s) +
      matrix(Model$rho.y/lambda.s,ncol=1) %*% matrix(values.s,nrow=1)
  ) * Q
  matrix.GDP.h <- H
  
  # For nominal bonds (initialization):
  b.h_1 <- 0
  F.nom <- matrix(1,nb.values.s,1)
  
  count <- 0
  for(h in 1:max(vec.maturities)){
    
    # Real bonds: ---------------------------------------------------------
    F.rea <- matrix.real.h_1 %*% matrix(exp(-mu.r))
    matrix.real.h_1 <- matrix.real.h_1 %*% (Q %*% diag(exp(-mu.r)))
    
    # GDP.indexed bonds: ---------------------------------------------------------
    F.GDP <- apply(matrix.GDP.h,1,sum)
    matrix.GDP.h <- matrix.GDP.h %*% H
    
    # Nominal bonds: ---------------------------------------------------------
    F.nom <- exp(-(b.h_1+1)*Model$pi.bar*(1 - Model$psi) + .5 * (b.h_1+1)^2 * Model$sigma.pi^2) *
      (exp(
        matrix(- mu.r + Model$rho.pi * (b.h_1+1) * ((1 - Model$phi) * s.bar / lambda.s + Model$phi * values.s / lambda.s),
               nb.values.s,nb.values.s) - Model$rho.pi * (b.h_1+1) *
          matrix(1/lambda.s,ncol=1) %*% matrix(values.s,nrow=1)
      ) * Q) %*% F.nom
    b.h_1 <- (1 + b.h_1) * Model$psi
    
    if(sum(h==vec.maturities)>0){
      count <- count + 1
      all.rea.bond.prices <- rbind(all.rea.bond.prices,c(F.rea))
      all.GDP.bond.prices <- rbind(all.GDP.bond.prices,c(F.GDP))
      
      all.rea.bond.yields <- rbind(all.rea.bond.yields,
                                   c(-Model$freq/vec.maturities[count] * log(F.rea)))
      all.GDP.bond.yields <- rbind(all.GDP.bond.yields,
                                   c(-Model$freq/vec.maturities[count] * log(F.GDP)))
      
      all.nom.bond.F      <- rbind(all.nom.bond.F,c(F.nom))
      all.nom.bond.b      <- rbind(all.nom.bond.b,b.h_1)
    }
  }
  
  
  # ======================================================================================
  # Computation of stock returns
  
  J <- exp(Model$d.bar + .5 * Model$sigma.d^2) * exp(
    matrix(- mu.r - (1 - Model$phi) * Model$rho.d * s.bar / lambda.s - Model$phi * Model$rho.d * values.s / lambda.s,
           nb.values.s,nb.values.s) +
      matrix(Model$rho.d/lambda.s,ncol=1) %*% matrix(values.s,nrow=1)
  ) * Q
  Chi <- solve(diag(nb.values.s) - J) %*% J %*% matrix(1,nb.values.s,1)
  
  M <- exp(Model$d.bar + Model$sigma.d^2/2) *
    exp(
      matrix(- (1 - Model$phi) * s.bar / lambda.s - Model$phi * values.s / lambda.s,
             nb.values.s,nb.values.s) +
        matrix(1/lambda.s,ncol=1) %*% matrix(values.s,nrow=1)) *
    (matrix(1/Chi,nb.values.s,1) %*% matrix(1 + Chi,1,nb.values.s))
  
  Exp.stock.return <- (M * P) %*% matrix(1,nb.values.s,1) - 1
  CondVar.stock.return <- diag(
    P %*% (M * M) - (P %*% M) * (P %*% M)
  )
  
  # Computation of conditional returns for horizon h.stock:
  
  H.h_1 <- diag(nb.values.s) # initialization
  V.h_1 <- matrix(0,nb.values.s,1) # initialization
  
  for(i in 1:h.stock){
    A.h_1 <- M * (matrix(1,nb.values.s,1) %*% matrix(diag(H.h_1),nrow=1))
    V.h_1 <- diag(
      (M * M * (matrix(1,nb.values.s,1) %*% matrix(V.h_1,nrow=1))) %*% t(P) +
        P %*% (A.h_1 * A.h_1) - (P %*% A.h_1) * (P %*% A.h_1)
    )
    H.h_1 <- M %*% diag(diag(H.h_1)) %*% t(P)
  }
  
  V.h <- V.h_1
  H.h <- H.h_1 - 1
  
  # prepare stock-return outputs:
  Exp.stock.return.h <- diag(H.h)
  Var.stock.return.h <- exp(h * Model$sigma.d^2) * V.h + 
    (exp(h * Model$sigma.d^2) - 1) * (Exp.stock.return.h * Exp.stock.return.h)
  cond.stock.Sharpe.ratios.h <- Exp.stock.return.h/sqrt(Var.stock.return.h)
  
  
  return(list(
    Model.solved = Model.solved,
    values.s = values.s,
    values.S = values.S,
    nb.values.s = nb.values.s,
    lambda.s = lambda.s,
    s.bar = s.bar,
    index.s.bar = index.s.bar,
    H = H,
    J = J,
    Chi = Chi,
    Exp.stock.return = Exp.stock.return,
    CondVar.stock.return = CondVar.stock.return,
    Exp.stock.return.h = Exp.stock.return.h,
    Var.stock.return.h = Var.stock.return.h,
    cond.var.SDF = cond.var.SDF,
    cond.stock.Sharpe.ratios.h = cond.stock.Sharpe.ratios.h,
    P = P,
    Q = Q,
    M = M,
    E.exp.rhoy.nu = E.exp.rhoy.nu,
    matrix.M.on.E.M = matrix.M.on.E.M,
    cond.max.Sharpe.ratios = cond.max.Sharpe.ratios,
    A=A,
    mu.r = mu.r,
    mu.r.1 = mu.r.1,
    all.rea.bond.prices = all.rea.bond.prices,
    all.rea.bond.yields = all.rea.bond.yields,
    all.GDP.bond.prices = all.GDP.bond.prices,
    all.GDP.bond.yields = all.GDP.bond.yields,
    all.nom.bond.F = all.nom.bond.F,
    all.nom.bond.b = all.nom.bond.b
  ))
}



simul.debt <- function(r.series,
                       r.gdp.series,past.issuances,
                       y.a.series,y.series){
  # past.issuances is a (h x 1) vector whose components are iss_{-h+1},iss_{-h+2},...iss_{0}.
  # The first h values of r.series, y.series etc correspond to periods t = -h+1,...,-1,0.
  # y.series contains values of log(Y_t/Y_{t-1})
  
  h <- length(past.issuances)
  T <- length(r.series)
  
  all.issuances <- past.issuances
  all.s <- rep(NaN,h)
  all.d <- rep(NaN,h)
  
  all.issuances.star <- past.issuances
  all.s.star <- rep(NaN,h)
  
  past.issuances.t_1 <- past.issuances
  past.issuances.star.t_1 <- past.issuances
  
  for(t in (h+1):T){
    vec.y.t_h.t <- cumsum(y.series[t:(t-h+1)])[h:1]
    vec.y.t_h.t_1 <- vec.y.t_h.t - vec.y.t_h.t[h]
    
    vec.t   <- exp((h:1)    *r.series[(t-h):(t-1)] - vec.y.t_h.t)
    vec.t_1 <- exp(((h-1):0)*r.series[(t-h):(t-1)] - vec.y.t_h.t_1)
    
    s.t <- sum((vec.t - vec.t_1) * past.issuances.t_1)
    iss.t <- past.issuances.t_1[1] * exp(h*r.series[t-h] - vec.y.t_h.t[1]) - s.t
    
    #     if(iss.t < 0){
    #       iss.t <- 0
    #       s.t <- past.issuances.t_1[1] * exp(h*r.series[t-h] - vec.y.t_h.t[1])
    #     }
    
    all.s <- c(all.s,s.t)
    all.issuances <- c(all.issuances,iss.t)
    
    
    d.t <- sum(vec.t * past.issuances.t_1) - s.t
    all.d <- c(all.d,d.t)
    
    
    if(h>1){
      past.issuances.t_1 <- c(past.issuances.t_1[2:h],iss.t)
    }else{
      past.issuances.t_1 <- c(iss.t)
    }
    
    
    vec.y.a.t_h.t <- cumsum(y.a.series[t:(t-h+1)])[h:1]
    vec.y.a.t_h.t_1 <- vec.y.a.t_h.t - vec.y.a.t_h.t[h]
    
    vec.star.t   <- exp((h:1)    *r.gdp.series[(t-h):(t-1)] - vec.y.a.t_h.t)
    vec.star.t_1 <- exp(((h-1):0)*r.gdp.series[(t-h):(t-1)] - vec.y.a.t_h.t_1)
    
    s.t.star <- sum((vec.star.t - vec.star.t_1) * past.issuances.star.t_1)
    iss.t.star <- past.issuances.star.t_1[1] * exp(h*r.gdp.series[t-h] - vec.y.a.t_h.t[1]) - s.t.star
    
    all.s.star <- c(all.s.star,s.t.star)
    all.issuances.star <- c(all.issuances.star,iss.t.star)
    
    if(h>1){
      past.issuances.star.t_1 <- c(past.issuances.star.t_1[2:h],iss.t.star)
    }else{
      past.issuances.star.t_1 <- c(iss.t.star)
    }
    
  }
  
  return(list(
    all.s = all.s,
    all.d = all.d,
    all.issuances = all.issuances,
    all.s.star = all.s.star,
    all.issuances.star = all.issuances.star
  ))
}


compute.uncond.mom.pi.z <- function(Model){
  
  P <- Model$P
  
  #print(P)
  EIG <- eigen(t(P))
  E.z <- matrix(
    abs(EIG$vectors[,1])/sum(abs(EIG$vectors[,1])),
    ncol=1)
  V.z <- diag(c(E.z)) - E.z %*% t(E.z)
  
  B <-
    matrix(1/Model$lambda.s,ncol=1) %*% matrix(Model$values.s,nrow=1) -
    matrix((1 - Model$phi) * Model$s.bar / Model$lambda.s + Model$phi * Model$values.s / Model$lambda.s,
           Model$nb.values.s,Model$nb.values.s)
  
  V.pi <- (Model$sigma.pi^2 +
             Model$rho.pi^2 * matrix(
               diag(P %*% (t(B) * t(B)) - (P %*% t(B))*(P %*% t(B))),1,Model$nb.values.s) %*% E.z)/
    (1-Model$psi^2)
  
  Cov.pi.z <- Model$rho.pi * solve(diag(Model$nb.values.s) - Model$psi * t(P)) %*%
    (t(P) * t(B) - t(P) * (matrix(1,Model$nb.values.s,Model$nb.values.s) %*% (t(P) * t(B)))) %*% E.z
  
  Var.pi.z <- rbind(
    c(V.pi,Cov.pi.z),
    cbind(Cov.pi.z,V.z)
  )
  
  E.pi.z <- matrix(c(Model$pi.bar,E.z),ncol=1)
  
  PHI <- matrix(0,Model$nb.values.s+1,Model$nb.values.s+1)
  PHI[1,1] <- Model$psi
  PHI[2:dim(PHI)[1],2:dim(PHI)[2]] <- t(P)
  
  AutoCov.pi.z <- PHI %*% Var.pi.z
  
  # Computation of average conditional covariance matrix of (pi,z')':
  G.E.z_pi <- (Model$sigma.pi^2 +
                 Model$rho.pi^2 * matrix(
                   diag(P %*% (t(B) * t(B)) - (P %*% t(B))*
                          (P %*% t(B))),1,Model$nb.values.s) %*% E.z)
  G.E.z_Cov.pi.z <- Model$rho.pi *
    (t(P) * t(B) - t(P) * (matrix(1,Model$nb.values.s,Model$nb.values.s)
                           %*% (t(P) * t(B)))) %*% E.z
  G.E.z_z <- diag(c(t(P) %*% E.z)) - t(P) %*% diag(c(E.z)) %*% P
  
  G.E.z <- rbind(
    c(G.E.z_pi,G.E.z_Cov.pi.z),
    cbind(G.E.z_Cov.pi.z,G.E.z_z)
  )
  
  # Computation of Var(nu):
  Var.nu <- Model$sigma.eps^2 +
    (1 - Model$p) * (Model$eta * Model$p / (1 - Model$p))^2 +
    Model$p * Model$eta^2
  
  #   # Computation of E(exp[rho.y * nu])
  #   E.exp.rhoy.nu <- exp(Model$rho.y^2 * Model$sigma.eps^2 / 2) *
  #     (Model$p * exp(- Model$eta * Model$rho.y) + 
  #        (1-Model$p) * exp( Model$eta * Model$p / (1 - Model$p) * Model$rho.y) )
  
  # Computation of Var(pi,y,c)
  Phi <- matrix(0,3,3)
  Phi[1,1] <- Model$psi
  Sigma <- diag(3)
  Sigma[1,3] <- Model$rho.pi
  Sigma[2,3] <- Model$rho.y
  vec.Var.pi.y.c <- solve(diag(9) - Phi %x% Phi) %*%
    c(Sigma %*% diag(c(Model$sigma.pi^2,Model$sigma.y^2,Var.nu)) %*% t(Sigma))
  Var.pi.y.c <- matrix(vec.Var.pi.y.c,3,3)
  stdv.pi.y.c <- sqrt(diag(Var.pi.y.c))
  Cor.pi.y.c <- Var.pi.y.c / (matrix(stdv.pi.y.c,ncol=1)%*%matrix(stdv.pi.y.c,nrow=1))
  
  return(list(
    E.z = E.z,
    V.z = V.z,
    V.pi = V.pi,
    Var.nu = Var.nu,
    # E.exp.rhoy.nu = E.exp.rhoy.nu,
    Cov.pi.z = Cov.pi.z,
    Var.pi.z = Var.pi.z,
    E.pi.z = E.pi.z,
    AutoCov.pi.z = AutoCov.pi.z,
    Var.pi.y.c = Var.pi.y.c,
    Cor.pi.y.c = Cor.pi.y.c,
    G.E.z = G.E.z
  ))
}


compute.moments <- function(Model,
                            vec.maturities, # maturities considered (expressed in number of model periods)
                            nb.values.s,
                            h.stock,
                            curvature,
                            grid.4.S,
                            indic.slope.nom.curve,
                            indic.slope.rea.curve,
                            indic.condVar.nom.rate,
                            indic.condVar.rea.rate)
{
  # vec.maturities is a vector indicating the maturities considered, these maturities
  #       are expressed in number of model's periods (i.e. 40 for 10-year bonds and quarterly-frequency models).
  # Yields output are annualized.
  
  RES.prices <- compute.prices(Model,
                               vec.maturities, # maturities considered (expressed in number of model periods)
                               nb.values.s,
                               h.stock,
                               curvature, # this controls the dispersion of S values in the grid (the higher this parameter, the larger the number of values XXX)
                               grid.4.S # If it is non NaN, then these values are used as a grid for S)
  )
  Model.solved <- RES.prices$Model.solved
  
  P <- RES.prices$P
  Q <- RES.prices$P
  values.s <- RES.prices$values.s
  nb.values.s <- RES.prices$nb.values.s
  index.s.bar <- RES.prices$index.s.bar
  
  unc.mom.pi.z <- compute.uncond.mom.pi.z(Model.solved)
  E.z <- unc.mom.pi.z$E.z
  V.z <- unc.mom.pi.z$V.z
  V.pi.z <- unc.mom.pi.z$Var.pi.z
  G.E.z <- unc.mom.pi.z$G.E.z
  AutoCov.pi.z <- unc.mom.pi.z$AutoCov.pi.z
  AutoCov.z <- AutoCov.pi.z[2:dim(AutoCov.pi.z)[1],2:dim(AutoCov.pi.z)[2]]
  
  stdv.pi <- sqrt(unc.mom.pi.z$Var.pi.y.c[1,1])
  stdv.dc <- sqrt(unc.mom.pi.z$Var.pi.y.c[3,3])
  stdv.pi <- sqrt(unc.mom.pi.z$Var.pi.y.c[1,1])
  stdv.dy <- sqrt(unc.mom.pi.z$Var.pi.y.c[2,2])
  
  # Average nominal yields
  RES.prices$all.nom.bond.F[RES.prices$all.nom.bond.F<=0] <- 10^(-50)
  mean.nom.yields <- Model$freq/vec.maturities * (
    RES.prices$all.nom.bond.b * Model$pi.bar - log(RES.prices$all.nom.bond.F) %*% E.z
  )
  
  # Std Dev nominal yields
  loadings.nom.yields <- Model$freq/vec.maturities * cbind(
    c(RES.prices$all.nom.bond.b),
    - log(RES.prices$all.nom.bond.F))
  var.nom.yds <- loadings.nom.yields %*% V.pi.z %*% t(loadings.nom.yields)
  autocov.nom.yds <- loadings.nom.yields %*% AutoCov.pi.z %*% t(loadings.nom.yields)
  stdv.nom.yds = sqrt(diag(var.nom.yds))
  cor.nom.yds <- var.nom.yds /
    (matrix(stdv.nom.yds,ncol=1) %*% matrix(stdv.nom.yds,nrow=1))
  autocor.nom.yds <- autocov.nom.yds /
    (matrix(stdv.nom.yds,ncol=1) %*% matrix(stdv.nom.yds,nrow=1))
  
  # Slope of the nominal yield curve
  mean.slope.nom.curve <- mean.nom.yields[indic.slope.nom.curve[2]]-
    mean.nom.yields[indic.slope.nom.curve[1]]
  
  # Std Dev slope of nominal yield curve
  loadings.nom.yield.slope <- loadings.nom.yields[indic.slope.nom.curve[2],] - 
    loadings.nom.yields[indic.slope.nom.curve[1],]
  loadings.nom.yield.slope <- matrix(loadings.nom.yield.slope,nrow=1)
  var.nom.yield.slope <- loadings.nom.yield.slope %*% V.pi.z %*% t(loadings.nom.yield.slope)
  stdv.nom.yield.slope <- sqrt(diag(var.nom.yield.slope))
  
  # Average real yields
  mean.rea.yields <- Model$freq/vec.maturities * (
    - log(RES.prices$all.rea.bond.prices) %*% E.z
  )
  
  # Std Dev real yields
  var.rea.yds <- RES.prices$all.rea.bond.yields %*% V.z %*% t(RES.prices$all.rea.bond.yields)
  autocov.rea.yds <- RES.prices$all.rea.bond.yields %*% AutoCov.z %*% t(RES.prices$all.rea.bond.yields)
  stdv.rea.yds <- sqrt(diag(var.rea.yds))
  cor.rea.yds <- var.rea.yds /
    (matrix(stdv.rea.yds,ncol=1) %*% matrix(stdv.rea.yds,nrow=1))
  autocor.rea.yds <- autocov.rea.yds /
    (matrix(stdv.rea.yds,ncol=1) %*% matrix(stdv.rea.yds,nrow=1))
  
  # Slope of the real yield curve
  mean.slope.rea.curve <- mean.nom.yields[indic.slope.rea.curve[2]]-
    mean.nom.yields[indic.slope.rea.curve[1]]
  
  # Std Dev slope of real yield curve
  loadings.rea.yield.slope <- RES.prices$all.rea.bond.yields[indic.slope.rea.curve[2],] - 
    RES.prices$all.rea.bond.yields[indic.slope.rea.curve[1],]
  loadings.rea.yield.slope <- matrix(loadings.rea.yield.slope,nrow=1)
  var.rea.yield.slope <- loadings.rea.yield.slope %*% V.z %*% t(loadings.rea.yield.slope)
  stdv.rea.yield.slope <- sqrt(diag(var.rea.yield.slope))
  
  # Average GDP-indexed yields
  mean.GDP.yields <- Model$freq/vec.maturities * (
    - log(RES.prices$all.GDP.bond.prices) %*% E.z
  )
  
  # Std Dev GDP-indexed yields
  var.GDP.yds <- RES.prices$all.GDP.bond.yields %*% V.z %*% t(RES.prices$all.GDP.bond.yields)
  stdv.GDP.yds <- sqrt(diag(var.GDP.yds))
  cor.GDP.yds <- var.GDP.yds /
    (matrix(stdv.GDP.yds,ncol=1) %*% matrix(stdv.GDP.yds,nrow=1))
  
  # Excess stock return
  E.r.m <- Model$freq * sum(RES.prices$Exp.stock.return * E.z)
  E.r.rf <- Model$freq * sum(RES.prices$mu.r * E.z)
  E.xs <- E.r.m - E.r.rf # average expected return (real terms)
  V.r.m <- sum(RES.prices$CondVar.stock.return * E.z) # average conditional variance
  E.P.over.D <- sum(RES.prices$Chi * E.z) / Model$freq
  var.P.over.D <- matrix(RES.prices$Chi/Model$freq,nrow=1) %*%
    V.z %*% matrix(RES.prices$Chi/Model$freq,ncol=1)
  
  # (Average) Conditional variances of nominal rates
  loadings.nom.4.condVar <- loadings.nom.yields[indic.condVar.nom.rate,]
  mean.of.CondVar.nom.yds <- loadings.nom.4.condVar %*% G.E.z %*%
    t(loadings.nom.4.condVar)
  mean.of.CondVar.nom.yds <- diag(mean.of.CondVar.nom.yds)
  
  # (Average) Conditional variances of real rates
  loadings.rea.4.condVar <- RES.prices$all.rea.bond.yields[indic.condVar.rea.rate,]
  loadings.rea.4.condVar <- matrix(loadings.rea.4.condVar,nrow=1)
  mean.of.CondVar.rea.yds <- loadings.rea.4.condVar %*% G.E.z[2:dim(G.E.z)[1],2:dim(G.E.z)[2]] %*%
    t(loadings.rea.4.condVar)
  mean.of.CondVar.rea.yds <- c(mean.of.CondVar.rea.yds)
  
  return(list(
    mean.nom.yields = mean.nom.yields,
    mean.rea.yields = mean.rea.yields,
    mean.GDP.yields = mean.GDP.yields,
    stdv.nom.yds = stdv.nom.yds,
    stdv.rea.yds = stdv.rea.yds,
    stdv.GDP.yds = stdv.GDP.yds,
    var.nom.yds = var.nom.yds,
    var.rea.yds = var.rea.yds,
    var.GDP.yds = var.GDP.yds,
    cor.nom.yds = cor.nom.yds,
    cor.rea.yds = cor.rea.yds,
    cor.GDP.yds = cor.GDP.yds,
    autocor.nom.yds = autocor.nom.yds,
    autocor.rea.yds = autocor.rea.yds,
    autocov.nom.yds = autocov.nom.yds,
    autocov.rea.yds = autocov.rea.yds,
    stdv.pi = stdv.pi,
    stdv.dy = stdv.dy,
    stdv.dc = stdv.dc,
    E.r.m = E.r.m,
    E.r.rf = E.r.rf,
    E.xs = E.xs,
    V.r.m = V.r.m,
    E.P.over.D = E.P.over.D,
    stdv.P.over.D = sqrt(var.P.over.D),
    mean.slope.nom.curve = mean.slope.nom.curve,
    mean.slope.rea.curve = mean.slope.rea.curve,
    stdv.nom.yield.slope = stdv.nom.yield.slope,
    stdv.rea.yield.slope = stdv.rea.yield.slope,
    mean.of.CondVar.nom.yds = mean.of.CondVar.nom.yds,
    mean.of.CondVar.rea.yds = mean.of.CondVar.rea.yds
  ))
}







correl.rm.na <- function(x,y){
  AUX <- x+y
  indic.which.is.not.na <- which(!is.na(AUX))
  x.aux <- x[indic.which.is.not.na]
  y.aux <- y[indic.which.is.not.na]
  return(cor(x.aux,y.aux))
}


compare.target.and.model <- function(Model,
                                     vec.maturities, # maturities considered (expressed in number of model periods)
                                     nb.values.s,
                                     h.stock,
                                     curvature,
                                     grid.4.S,
                                     indic.the.ones.used.in.nom.curve,
                                     indic.the.ones.used.in.rea.curve,
                                     indic.slope.nom.curve,
                                     indic.slope.rea.curve,
                                     indic.condVar.nom.rate,
                                     indic.condVar.rea.rate){
  
  res <- compute.moments(Model,
                         vec.maturities, # maturities considered (expressed in number of model periods)
                         nb.values.s,
                         h.stock,
                         curvature,
                         grid.4.S,
                         indic.slope.nom.curve,
                         indic.slope.rea.curve,
                         indic.condVar.nom.rate,
                         indic.condVar.rea.rate)
  
  modelled.moments <- c(Model$g,Model$g,Model$pi.bar,
                        res$stdv.dy,res$stdv.dc,res$stdv.pi,
                        res$mean.nom.yields[indic.the.ones.used.in.nom.curve],
                        res$stdv.nom.yds[indic.the.ones.used.in.nom.curve],
                        res$autocor.nom.yds[indic.the.ones.used.in.nom.curve[1],indic.the.ones.used.in.nom.curve[1]],
                        res$autocor.nom.yds[indic.the.ones.used.in.nom.curve[2],indic.the.ones.used.in.nom.curve[2]],
                        res$autocor.nom.yds[indic.the.ones.used.in.nom.curve[3],indic.the.ones.used.in.nom.curve[3]],
                        res$mean.slope.nom.curve, # slope of nominal yield curve
                        res$stdv.nom.yield.slope, # stdv of nominal yield curve
                        res$mean.rea.yields[indic.the.ones.used.in.rea.curve],
                        res$stdv.nom.yds[indic.the.ones.used.in.rea.curve],
                        res$autocor.rea.yds[indic.the.ones.used.in.rea.curve[1],indic.the.ones.used.in.rea.curve[1]],
                        res$autocor.rea.yds[indic.the.ones.used.in.rea.curve[2],indic.the.ones.used.in.rea.curve[2]],
                        res$autocor.rea.yds[indic.the.ones.used.in.rea.curve[3],indic.the.ones.used.in.rea.curve[3]],
                        res$mean.slope.rea.curve, # slope of real yield curve
                        res$stdv.rea.yield.slope, # stdv of real yield curve
                        res$mean.of.CondVar.nom.yds, # mean of conditional var of nominal yields (2 maturities)
                        #c(1000,1000), # stdv of conditional var of nominal yields (2 maturities)
                        res$mean.of.CondVar.rea.yds, # mean of condiitonal var of real yields (1 maturity)
                        #1000,  # stdv of condiitonal var of real yields (1 maturity)
                        res$E.xs, # annualized expected excess return on stocks
                        sqrt(Model$freq) * sqrt(res$V.r.m), # annualized conditional volatility
                        res$E.P.over.D, # average P over D (annualized)
                        res$stdv.P.over.D # stdv of P over D (annualized)
  )
  return(modelled.moments)
}

Theta.2.Model <- function(theta){
  Model <- list(
    sigma.eps = exp(theta[1]),
    phi = exp(theta[2])/(1 + exp(theta[2])),
    delta = exp(theta[3])/(1 + exp(theta[3])),
    b = NaN,
    Gamma = abs(theta[5]),
    g = theta[6],
    p = exp(theta[7])/(1 + exp(theta[7])),
    eta = abs(theta[8]),
    pi.bar = theta[9],
    psi = exp(theta[10])/(1 + exp(theta[10])),
    sigma.pi = exp(theta[11]),
    rho.pi = theta[12],
    sigma.y = exp(theta[13]),
    rho.y = theta[14],
    # =================================
    # =================================
    # =================================
    # d.bar = theta[15],
    d.bar = theta[6],
    # =================================
    # =================================
    # =================================
    sigma.d = exp(theta[16]),
    rho.d = theta[17],
    freq = FREQ
  )
  # Make sure that b < Gamma * (1 - phi)
  Model$b <- (1 - 2 *exp(theta[4])/(1 + exp(theta[4]))) *
    Model$Gamma * (1 - Model$phi)
  return(Model)
}

inv.logit <- function(rho){
  return(log(rho/(1-rho)))
}

Model.2.Theta <- function(Model){
  Theta <- c(
    log(Model$sigma.eps),
    inv.logit(Model$phi),
    inv.logit(Model$delta),
    inv.logit(.5*(1 - Model$b/(Model$Gamma * (1 - Model$phi)))),
    Model$Gamma,
    Model$g,
    inv.logit(Model$p),
    Model$eta,
    Model$pi.bar,
    inv.logit(Model$psi),
    log(Model$sigma.pi),
    Model$rho.pi,
    log(Model$sigma.y),
    Model$rho.y,
    Model$d.bar,
    log(Model$sigma.d),
    Model$rho.d
  )
  #Theta
  
  return(Theta)
}


compute.criteria <- function(Theta.0,
                             vec.maturities, # maturities considered (expressed in number of model periods)
                             nb.values.s,
                             h.stock,
                             curvature,
                             grid.4.S,
                             indic.the.ones.used.in.nom.curve,
                             indic.the.ones.used.in.rea.curve,
                             indic.slope.nom.curve,
                             indic.slope.rea.curve,
                             indic.condVar.nom.rate,
                             indic.condVar.rea.rate,
                             all.targets,
                             all.weights){
  
  
  Theta <- Full.Theta
  Theta[Filter==1] <- Theta.0
  
  Model <- Theta.2.Model(Theta)
  
  modelled.moments <- compare.target.and.model(Model,
                                               vec.maturities, # maturities considered (expressed in number of model periods)
                                               nb.values.s,
                                               h.stock,
                                               curvature,
                                               grid.4.S,
                                               indic.the.ones.used.in.nom.curve,
                                               indic.the.ones.used.in.rea.curve,
                                               indic.slope.nom.curve,
                                               indic.slope.rea.curve,
                                               indic.condVar.nom.rate,
                                               indic.condVar.rea.rate)
  
  loss <- sum((modelled.moments - all.targets)^2/all.weights^2)
  
  loss <- loss + 10^10 * sum((abs(Theta.0)>max.abs.value.params)*(abs(Theta.0)-max.abs.value.params))
  
  if(is.na(loss)){
    #print("NA loss")
    #print(modelled.moments)
    save(Theta.0,Filter,Full.Theta,file = "results/tempo_NaN.Rdat")
  }
  
  
  return(c(loss))
}

round.fixed.length.old <- function(X,n){
  # This procedure is used in the automatic creation of Latex tables
  # x is numeric. The output is a string with n numbers after ".", even if they are 0s.
  signX <- sign(X)
  if(signX>=0){
    signX <- NULL
  }else{
    signX <- "-"
  }
  x <- abs(X)
  string.integer <- toString(as.integer(x))
  string.decimal <- trunc(10^n*(x - as.integer(x,0)))/10^n
  # string.decimal <- toString(round(x - as.integer(x,0),n))
  while(nchar(string.decimal)<n+2){
    string.decimal <- paste(string.decimal,"0",sep="")
  }
  if(n==0){
    string.x <- paste(signX,string.integer,sep="")
  }else{
    string.x <- paste(signX,string.integer,".",str_replace(string.decimal,"0.",""),sep="")
  }
  return(string.x)
}

round.fixed.length <- function(X,n){
  # This procedure is used in the automatic creation of Latex tables
  # x is numeric. The output is a string with n numbers after ".", even if they are 0s.
  signX <- sign(X)
  if(signX>=0){
    signX <- NULL
  }else{
    signX <- "-"
  }
  x <- abs(X)
  rounded.abs.X <- round(X,n)
  string.rounded.abs.X <-toString(rounded.abs.X)
  nb.char.string.rounded.abs.X <- nchar(string.rounded.abs.X)
  
  integer.rounded.abs.X <- toString(as.integer(rounded.abs.X))
  nb.char.integer.rounded.abs.X <- nchar(integer.rounded.abs.X)
  
  string.x <- paste(signX,integer.rounded.abs.X,sep="")
  
  if(n>0){
    string.x <- paste(string.x,".",sep="")
    nb.of.available.decimal <- nb.char.string.rounded.abs.X - nb.char.integer.rounded.abs.X - 1
    for(i in 1:n){
      if(i<=nb.of.available.decimal){
        string.x <- paste(string.x,str_sub(string.rounded.abs.X,
                                           nb.char.integer.rounded.abs.X+1+i,
                                           nb.char.integer.rounded.abs.X+1+i),sep="")
      }else{
        string.x <- paste(string.x,"0",sep="")
      }
    }
    
    #string.x <- paste(signX,string.integer,".",str_replace(string.decimal,"0.",""),sep="")
  }
  return(string.x)
}


Kurtosis <- function(Y){
  X <- Y[!is.na(Y)]
  MN <- mean(X)
  SD <- sd(X)
  if(class(X)=="numeric"){
    Y <- t(X-MN)/SD
  } else {
    Y <- (X-MN)/SD
  }
  k = 1/max(dim(Y))*sum(Y^4)
  return(k)
}

skewness <- function(Y){
  X <- Y[!is.na(Y)]
  MN <- mean(X)
  SD <- sd(X)
  if(class(X)=="numeric"){
    Y <- t(X-MN)/SD
  } else {
    Y <- (X-MN)/SD
  }
  k = 1/max(dim(Y))*sum(Y^3)
  return(k)
}

kurtosis <- function(mu.1,p,S){
  # p and mu.1 are scalar
  # not appropriate for mu.1 = 0.
  s <- S
  s[s>2*(1-p)/sqrt(p*(2-p))] <- NaN
  s[s< -2*(1-p)/sqrt(p*(2-p))] <- NaN
  
  sigma.12 <- (1-p)/(3*p*mu.1)*(s - mu.1^3*(p - p^3/(1-p)^2 + 3*p^2/(1-p)^2) +
                                  3*mu.1*p/(1-p))
  indic.zero.skew <- which(S==0)
  sigma.12[indic.zero.skew] <- 1 - mu.1^2/3
  
  sigma.22 <- 1/(1-p)*(1 - p*sigma.12 - p/(1-p)*mu.1^2)
  
  mu.2 <- -p*mu.1/(1 - p)
  
  kurt <- p*(mu.1^4 + 6*mu.1^2*sigma.12 + 3*sigma.12^2) +
    (1-p)*(mu.2^4 + 6*mu.2^2*sigma.22 + 3*sigma.22^2)
  
  kurt[sigma.12 <0] <- NaN
  kurt[sigma.22 <0] <- NaN
  
  return(kurt)
}

get.Gaussian.mixture.from.kappa <- function(kappa.3,kappa.4,p,indic.plot.distri=TRUE){
  # Find parameterization that is consistent with kappa.3 and kappa.4:
  
  mu.1 <- seq(-30,30,by=.0001)
  
  kappa.4.vec <- kurtosis(mu.1,p,kappa.3) - 3
  kappa.4.vec[is.na(kappa.4.vec)] <- 10000
  
  indic.sol <- which((kappa.4.vec-kappa.4)^2==min((kappa.4.vec-kappa.4)^2,na.rm=TRUE))
  mu.1.est <- mu.1[indic.sol[1]]
  sigma.12 <- (1-p)/(3*p*mu.1.est)*(kappa.3 - mu.1.est^3*(p - p^3/(1-p)^2 + 3*p^2/(1-p)^2) +
                                      3*mu.1.est*p/(1-p))
  sigma.22 <- 1/(1-p)*(1 - p*sigma.12 - p/(1-p)*mu.1.est^2)
  mu.2 <- -p*mu.1.est/(1 - p)
  # Compute standard deviations:
  sigma.1 <- sqrt(sigma.12)
  sigma.2 <- sqrt(sigma.22)
  
  # Check results:
  step <- .001
  xx <- seq(-30,30,by=step)
  f.0 <- p * dnorm((xx-mu.1.est)/sigma.1)/sigma.1 + (1 - p) * dnorm((xx-mu.2)/sigma.2)/sigma.2
  if(indic.plot.distri){
    par(plt=c(.1,.9,.1,.9))
    plot(xx,f.0,type="l")
  }
  print(paste("Variance of distri.:",toString(sum(xx^2*f.0)*step),sep=""))
  print(paste("kappa_3 of distri.:",toString(sum(xx^3*f.0)*step),sep=""))
  print(paste("kappa_4 of distri.:",toString(sum(xx^4*f.0)*step-3),sep=""))
  #print(sum(xx^5*f.0)*step - 10*sum(xx^3*f.0)*step*sum(xx^2*f.0)*step)
  
  return(list(
    mu.1 = mu.1.est,
    mu.2 = mu.2,
    sigma.1 = sigma.1,
    sigma.2 = sigma.2
  ))
}


# param.Gaussian.mixt <- get.Gaussian.mixture.from.kappa(skewness(dc.US),
#                                                        Kurtosis(dc.US)-3,
#                                                        p=.02,
#                                                        indic.plot.distri=TRUE)
# aux <- (dc.US - mean(dc.US))/sd(dc.US)
# lines(density(aux,bw=.7),col="red")

